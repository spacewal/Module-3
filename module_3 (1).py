# -*- coding: utf-8 -*-
"""Module 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xUhu1hn45-ck0QwTENXuCg8_ZjUFcv4p
"""

!pip install lifetimes

# Customer Lifetime Value (CLV or CLTV)
# Buy till you die... (BG/NBD)
# data:  https://github.com/fenago/datasets/raw/main/Online%20Retail.xlsx

import lifetimes
import pandas as pd
import numpy as np
import datetime as dt
import matplotlib.pyplot as plt
import seaborn as sns
from lifetimes import BetaGeoFitter # BG/NBD
from lifetimes import GammaGammaFitter # Gamma-Gamma Model
from lifetimes.plotting import plot_frequency_recency_matrix
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)

df = pd.read_csv("https://raw.githubusercontent.com/spacewal/Module-3/main/synthetic_grocery_data.csv")

df.info()

df['Transaction Date'] = pd.to_datetime(df['Transaction Date'])

df.info()

df.describe()

def find_boundaries(df, variable,q1=0.05,q2=0.95):
    # the boundaries are the quantiles
    lower_boundary = df[variable].quantile(q1) # lower quantile
    upper_boundary = df[variable].quantile(q2) # upper quantile
    return upper_boundary, lower_boundary
def capping_outliers(df,variable):
    upper_boundary,lower_boundary =  find_boundaries(df,variable)
    df[variable] = np.where(df[variable] > upper_boundary, upper_boundary,
                       np.where(df[variable] < lower_boundary, lower_boundary, df[variable]))

'''capping_outliers(df,'quantity')
capping_outliers(df,'Quantity')'''

"""# RFM"""

df.head(2)

df['Total Price'] = df['Price'] * df['Volume Purchased']

df['Transaction Date'].max()

df['Transaction Date'].min()

clv = lifetimes.utils.summary_data_from_transaction_data(df,'User ID','Transaction Date','Total Price',observation_period_end='2024-02-23 06:20:45.207358')

clv.head(10)

# let's filter so that we only catch customers who have made more than 1 purchase
clv = clv[clv['frequency']>1]

clv.head()

"""# BG/NBD Model"""

bgf = BetaGeoFitter(penalizer_coef=0.001)  # This will allow you to predict FUTURE purchase by taking into account F, R, T  penalizer is used to avoid overfitting
bgf.fit(clv['frequency'], clv['recency'], clv['T'])

t = 180 # 6 month/180 day period
clv['expected_purc_6_months'] = bgf.conditional_expected_number_of_purchases_up_to_time(t, clv['frequency'], clv['recency'], clv['T'])
clv.sort_values(by='expected_purc_6_months',ascending=False).head(5)

"""# Gamma-Gamma Model"""

clv[['frequency','monetary_value']].corr()

ggf = GammaGammaFitter(penalizer_coef=0.01)
ggf.fit(clv["frequency"],
        clv["monetary_value"])

clv['six_Months_CLV']=ggf.customer_lifetime_value(bgf,
                                   clv["frequency"],
                                   clv["recency"],
                                   clv["T"],
                                   clv["monetary_value"],
                                   time=6,
                                   freq='D',
                                   discount_rate=0.01)
clv.sort_values('six_Months_CLV',ascending=False).head()

clv['Segment'] =  pd.qcut(clv['six_Months_CLV'],4,labels = ['Hibernating','Need Attention', 'LoyalCustomers', 'Champions'])

clv.head()

clv.groupby('Segment').mean()